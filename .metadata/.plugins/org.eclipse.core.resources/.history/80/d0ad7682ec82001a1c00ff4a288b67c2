package com.mars.generator;

public class Coordinate {
	
	    private int axisCoordinate;
	    private int ordinateCoordinate;

	    public Coordinate(final int xCoordinate, final int yCoordinate) {
	        this.axisCoordinate = xCoordinate;
	        this.ordinateCoordinate = yCoordinate;
	    }

	    public Coordinate newCoordinatesXY(final int xValue, final int yValue) {
	        return new Coordinate(this.axisCoordinate + xValue, this.ordinateCoordinate + yValue);
	    }

	    @Override
	    public String toString() {
	        StringBuilder coordinateOutput = new StringBuilder();
	        coordinateOutput.append(axisCoordinate);
	        coordinateOutput.append(" ");
	        coordinateOutput.append(ordinateCoordinate);
	        return coordinateOutput.toString();
	    }

	  
	    private boolean yWithIn( int yCoordinate) {
			if (yCoordinate <= this.ordinateCoordinate) {
				return true;
			} else
				return false;
	
		}

	  
	    private boolean xWithIn( int xCoordinate) {
	    	
		if (xCoordinate <= this.axisCoordinate) {
			return true;
		}else
			return false;
	    }

		private boolean xOutside(int xCoordinate) {
	
			if (xCoordinate <= this.axisCoordinate) {
				return true;
			} else
				return false;
		}

		private boolean yOutside(int yCoordinate) {
			if (yCoordinate <= this.ordinateCoordinate) {
				return true;
			} else
				return false;
	
		}

	    public Coordinate newCoordinates(final int xValue,  int yValue) {
	        return new Coordinate(axisCoordinate+xValue, ordinateCoordinate+yValue);
	    }
	    
	    public boolean outside( Coordinate coordinates) {
	        return xOutside(coordinates.axisCoordinate) && yOutside(coordinates.ordinateCoordinate);
	    }
	    
	    public boolean within( Coordinate coordinates) {
	        return xWithIn(coordinates.axisCoordinate) && yWithIn(coordinates.ordinateCoordinate);
	    }


}
